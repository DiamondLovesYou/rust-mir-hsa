
use std::error::Error;
use std::fs::File;
use std::io::{Write, Read, };
use std::process::Command;
use std::sync::Arc;

use lrt_core::accelerators::RustBuildRoot;
use lrt_core::codegen::*;

use rustc::hir::{SpirVTypeSpec, SpirVAttrNode, };
use rustc::session::config::OutputType;
use rustc::ty::{ParamEnv, FnDef, AdtDef, };
use tempdir::TempDir;

pub type CodegenShaderInterface = (StaticShaderInterfaceDef,
                                   StaticShaderInterfaceDef);

pub struct VkKernelDesc {
  pub exe_model: ExecutionModel,
  pub pipeline: StaticPipelineLayoutDesc,
  pub interface: Option<CodegenShaderInterface>,
  pub capabilities: Capabilities<'static, [Capability]>,
  pub extensions: &'static [&'static str],
}

pub struct VkPlatformCodegen;
impl PlatformCodegen for VkPlatformCodegen {
  fn root<'tcx>(&self,
                desc: PKernelDesc<Self>,
                did: DefId,
                tcx: TyCtxt<'tcx>,
                dd: &DriverData<'tcx, Self>)
    -> Result<PCodegenDesc<Self>, Box<dyn Error>>
  {
    unimplemented!()
  }
  fn root_conditions<'tcx>(&self, root: &PCodegenDesc<Self>,
                           _tcx: TyCtxt<'tcx>,
                           _dd: &DriverData<'tcx, Self>)
    -> Result<Vec<Self::Condition>, Box<dyn Error>>
  {
    Ok(vec![Condition::ExeModel(root.exe_model.into())])
  }
  fn post_codegen(&self,
                  target_desc: &Arc<AcceleratorTargetDesc>,
                  codegen: &mut CodegenResults<Self>)
    -> Result<(), Box<dyn Error>>
  {
    let tdir = TempDir::new("link-compilation")?;
    let obj_filename = tdir.path().join("obj.bc");
    {
      let mut out = File::create(&obj_filename)?;

      let obj = codegen.outputs
        .remove(&OutputType::Bitcode)
        .expect("no object output");

      out.write_all(&obj[..])?;
    }

    let rbr = RustBuildRoot::default();
    /*let mut linked_filename = tdir.path().join("linked.bc");
    if objs.len() > 0 {
      let mut cmd = Command::new(rbr.llvm_tool("llvm-link"));
      cmd.arg("-only-needed")
        .arg("-o").arg(&linked_filename)
        .arg(obj_filename)
        .args(objs);
      if !cmd.spawn()?.wait()?.success() {
        return Err("linking failed".into());
      }
      info!("linking: {:?}", cmd);
    } else {
      linked_filename = obj_filename;
    }*/
    let linked_filename = obj_filename;

    let spv_filename = tdir.path().join("codegen.spv");
    let mut cmd = Command::new(rbr.llvm_tool("llvm-spirv"));
    cmd
      .arg("-spirv-mem2reg=false") // this is already done by our optimizations
      .arg("-o").arg(&spv_filename)
      .arg(linked_filename);
    info!("codegen-ing: {:?}", cmd);

    if !cmd.spawn()?.wait()?.success() {
      return Err("codegen failed".into());
    }

    tdir.into_path();

    let mut bin = Vec::new();
    {
      let mut file = File::open(&spv_filename)?;
      file.read_to_end(&mut bin)?;
    }

    codegen.outputs.insert(OutputType::Exe, bin);

    Ok(())
  }
  /// Modify the provided `attrs` to suit the platforms needs.
  /// `attrs` is generated by vanilla Rustc.
  fn codegen_fn_attrs<'tcx>(&self,
                            tcx: TyCtxt<'tcx>,
                            dd: &DriverData<'tcx, Self>,
                            id: DefId,
                            attrs: &mut CodegenFnAttrs)
  {
    if dd.is_root(id) {
      let modes = dd.root()
        .execution_modes
        .iter()
        .map(|&mode| {
          match mode {
            ExecutionMode::LocalSize {
              x, y, z,
            } => {
              ("LocalSize".into(), vec![x as u64, y as _, z as _, ])
            },
            ExecutionMode::Xfb => {
              ("Xfb".into(), vec![])
            },
          }
        })
        .collect();

      attrs.spirv = Some(SpirVAttrs {
        storage_class: None,
        metadata: None,
        exe_model: Some(format!("{:?}", dd.root().exe_model())),
        exe_mode: Some(modes),
      });
    } else if tcx.is_static(id).is_some() {
      let inst = Instance::mono(tcx, id);
      let ty = inst.ty(tcx);
      // check for function types. We don't attach any spirv
      // metadata to functions.
      match ty.sty {
        FnDef(..) => {
          attrs.spirv = None;
        },
        _ => {
          let global_attrs = geobacter_global_attrs(tcx,
                                                    dd.root().exe_model(),
                                                    inst,
                                                    false);

          if let Some(_) = global_attrs.spirv_builtin {
            // remove the linkage attr. This is used on the host to
            // prevent linker errors.
            attrs.linkage = None;
          }

          warn!("building metadata for {:?}", id);
          warn!("{:?} attrs: {:#?}", id, global_attrs);

          let mut metadata = build_spirv_metadata(tcx, dd, inst,
                                                  &global_attrs);

          let sc = global_attrs.storage_class(&dd.root_conditions);
          match sc {
            Some(StorageClass::Uniform) |
            Some(StorageClass::StorageBuffer) => {
              if let Some(ref mut metadata) = metadata {
                metadata.decorations.push(("Block".into(), vec![]));
              }
            },
            _ => {},
          }

          attrs.spirv = Some(SpirVAttrs {
            storage_class: sc.map(|sc| format!("{:?}", sc) ),
            metadata,
            exe_model: None,
            exe_mode: None,
          });
        },
      }
    }
  }
}

fn default_node() -> SpirVAttrNode {
  SpirVAttrNode {
    type_spec: default_ty_spec(),
    builtin: None,
    decorations: vec![],
  }
}
fn default_ty_spec() -> SpirVTypeSpec {
  SpirVTypeSpec::Struct(vec![])
}

fn build_spirv_adt_metadata<'a, 'b, 'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,
                                          dd: &'b DriverData<'tcx>,
                                          inst: Instance<'tcx>,

                                          ty: ty::Ty<'tcx>,
                                          adt_def: &'tcx AdtDef,
                                          substs: &'tcx Substs<'tcx>)
  -> SpirVAttrNode
{
  //let layout = dd.host_layout_of(ty);
  let layout = tcx.layout_of(ParamEnv::reveal_all().and(ty))
    .unwrap();

  warn!("{:?} layout: {:#?}", ty, layout);

  let cx = ty::layout::LayoutCx {
    tcx,
    param_env: ParamEnv::reveal_all(),
  };

  // TODO won't be true for enums. Not sure what the layout would
  // look like.
  assert_eq!(adt_def.variants.len(), 1, "TODO: {:?}, layout: {:?}",
             adt_def, layout);

  let mut nodes = vec![];

  for i in layout.fields.index_by_increasing_offset() {
    let offset = layout.details.fields.offset(i as usize);
    let field = layout.field(&cx, i).unwrap();
    let ty = field.ty;
    let ty = tcx
      .subst_and_normalize_erasing_regions(substs,
                                           ParamEnv::reveal_all(),
                                           &ty);
    let mut node = build_spirv_ty_metadata(tcx, dd, inst, ty);

    node.decorations.push(("Offset".into(), vec![offset.bytes() as _]));

    nodes.push(node);
  }

  let decorations = vec![];

  SpirVAttrNode {
    type_spec: SpirVTypeSpec::Struct(nodes),
    builtin: None,
    decorations,
  }
}

fn build_spirv_ty_metadata<'a, 'b, 'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,
                                         dd: &'b DriverData<'tcx>,
                                         inst: Instance<'tcx>,

                                         ty: ty::Ty<'tcx>)
  -> SpirVAttrNode
{
  use rustc::ty::*;

  // we have to be careful of recursion here
  // we don't maintain a set of visited types but in this case we can skip
  // some types: we require `T: Sized + Copy + 'static` (TODO pointers?).

  // TODO: should we allow builtins as struct members? I want to say no.

  info!("build_spirv_ty_metadata: ty.sty = {:?}", ty.sty);

  let ty = tcx
    .subst_and_normalize_erasing_regions(inst.substs,
                                         ParamEnv::reveal_all(),
                                         &ty);

  match ty.sty {
    Bool | Char | Int(_) | Uint(_) | Float(_) => {
      default_node()
    },
    Adt(adt_def, _substs) if adt_def.repr.simd() => {
      let layout = tcx.layout_of(ParamEnv::reveal_all().and(ty))
        .unwrap();

      warn!("{:?} layout: {:#?}", ty, layout);
      // TODO someday we'll want to allow `RowMajor` and `ColMajor` etc
      default_node()
    },
    Adt(adt_def, substs) if adt_def.repr.transparent() => {
      // extract the inner type which this type wraps. This can be important
      // for wrappers which wrap SIMD types, for example SPIRV Vector and Matrix
      // types.
      let idx = VariantIdx::new(0);
      let field = adt_def.variants[idx].fields[0].did;
      let field_ty = tcx.type_of(field);

      let field_ty = tcx
        .subst_and_normalize_erasing_regions(substs,
                                             ParamEnv::reveal_all(),
                                             &field_ty);
      trace!("repr(transparent): extracted {:?}", field_ty);
      build_spirv_ty_metadata(tcx, dd, inst, field_ty)
    },
    Tuple(elements) => {
      //let layout = dd.host_layout_of(ty);
      let layout = tcx
        .layout_of(ParamEnv::reveal_all().and(ty))
        .unwrap()
        .details;

      let mut nodes = vec![];

      for (idx, element) in elements.iter().enumerate() {
        let offset = layout.fields.offset(idx);
        let mut node = build_spirv_ty_metadata(tcx, dd, inst, element);
        node.decorations.push(("Offset".into(), vec![offset.bytes() as _]));

        nodes.push(node);
      }

      SpirVAttrNode {
        type_spec: SpirVTypeSpec::Struct(nodes),
        builtin: None,
        decorations: vec![],
      }
    },
    Adt(adt_def, substs) => {
      build_spirv_adt_metadata(tcx, dd, inst, ty, adt_def, substs)
    },
    Array(inner, _count) => {
      let type_spec = SpirVTypeSpec::Array(Box::new(build_spirv_ty_metadata(tcx, dd, inst,
                                                                            inner)));

      let layout = tcx.layout_of(ParamEnv::reveal_all().and(inner))
        .unwrap();

      let node = SpirVAttrNode {
        type_spec,
        builtin: None,
        decorations: vec![("ArrayStride".into(),
                           vec![layout.details.size.bytes() as _])],
      };
      node
    },

    _ => {
      panic!("shouldn't be allowed or unimplemented TODO: {:?}", ty);
    },
  }
}

fn build_spirv_metadata<'a, 'b, 'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,
                                      dd: &'b DriverData<'tcx>,
                                      inst: Instance<'tcx>,
                                      attrs: &GlobalAttrs)
  -> Option<SpirVAttrNode>
{
  let ty = inst.ty(tcx);

  // extract the pointer
  let ty = if let ty::RawPtr(tm) = ty.sty {
    tm.ty
  } else {
    // this probably isn't correct...
    ty
  };

  let mut node = build_spirv_ty_metadata(tcx, dd, inst, ty);

  // descriptor set/binding is only allowed on top level global statics.
  // so this is only processed in this non-recursive function.
  let (opt_set, opt_binding) =
    optional_descriptor_set_binding_nums(tcx, inst.def_id());

  if let Some(builtin) = attrs.spirv_builtin {
    node.decorations.push(("BuiltIn".into(), vec![builtin as _]));
  }
  if let Some(set_num) = opt_set {
    node.decorations.push(("DescriptorSet".into(), vec![set_num as _]));
  }
  if let Some(binding_num) = opt_binding {
    node.decorations.push(("Binding".into(), vec![binding_num as _]));
  }

  Some(node)
}
